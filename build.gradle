import java.util.zip.ZipFile
/*
 * This file was generated by the Gradle 'init' task.
 *
 * This generated file contains a sample Java library project to get you started.
 * For more details take a look at the 'Building Java & JVM projects' chapter in the Gradle
 * User Manual available at https://docs.gradle.org/8.1.1/userguide/building_java_projects.html
 */
buildscript {
	repositories {
		gradlePluginPortal()
		mavenCentral()
	}

}


plugins {
	id 'java'
	id 'application'
	id 'eclipse'
	id 'com.github.johnrengelman.shadow' version '8.1.1' apply false
    id 'org.openjfx.javafxplugin' version '0.0.13'apply false
}
// Only apply to the root project
if (project == rootProject) {
	apply plugin: 'com.github.johnrengelman.shadow'
	apply plugin: 'org.openjfx.javafxplugin'
}

allprojects {
	repositories {
		mavenCentral()
		gradlePluginPortal()
	}

}
subprojects {
	apply plugin: 'java'
	apply plugin: 'eclipse'
    sourceCompatibility = 1.8
    targetCompatibility = 1.8

    eclipse {
        classpath {
            downloadSources = true
            downloadJavadoc = true
            file {
                whenMerged {
                    entries.forEach { entry ->
                        if (entry.kind == 'lib') {
                            entry.entryAttributes['module'] = 'true'
                        }
                    }
                }
            }
        }
        jdt {
            sourceCompatibility = 1.8
            targetCompatibility = 1.8
        }
    }

	tasks.withType(JavaCompile) {
		options.encoding = 'UTF-8'
		options.compilerArgs << '-Xlint:deprecation' << '-Xlint:unchecked'
	}
}

subprojects { subproject ->
	subproject.afterEvaluate {
		if (subproject.plugins.hasPlugin('com.github.johnrengelman.shadow')) {
			subproject.tasks.matching { it.name == 'shadowJar' }.all {
				System.out.println("Disabling Shadowjar for "+it)
				it.enabled = false
			}
		}
	}
}




repositories {
	// Use Maven Central for resolving dependencies.
	mavenCentral()
	jcenter()
}

java {
	//modularity.inferModulePath.set(true)
}

dependencies {
	implementation project(':BowlerStudio:libraries:bowler-script-kernel:java-bowler')
	implementation project(':BowlerStudio:libraries:bowler-script-kernel:GithubPasswordManager:GithubPasswordManager')
	implementation project(':BowlerStudio:libraries:bowler-script-kernel')
	implementation project(':BowlerStudio:libraries:dockfx')
	implementation project(':BowlerStudio')
	
	
	// Use JUnit Jupiter for testing.
	testImplementation 'org.junit.jupiter:junit-jupiter:5.9.1'

	// This dependency is used internally, and not exposed to consumers on their own compile classpath.
	implementation 'com.google.guava:guava:31.1-jre'
	implementation 'com.google.code.gson:gson:2.8.6'
	implementation 'org.openjfx:javafx-controls:17'
	implementation 'org.openjfx:javafx-fxml:17'
	implementation 'org.openjfx:javafx-graphics:17'
		
}
javafx {
	version = '17' // or whichever version you're using
	modules = ['javafx.controls', 'javafx.fxml', 'javafx.graphics'] // add other modules as needed
}

tasks.withType(Test) {
	useJUnitPlatform()
	jvmArgs '--add-opens', 'java.base/java.lang=ALL-UNNAMED'
}
run {
	jvmArgs = [
		'--add-exports', 'javafx.controls/com.sun.javafx.scene.control.behavior=ALL-UNNAMED',
		'--add-exports', 'javafx.base/com.sun.javafx.event=ALL-UNNAMED',
		'--add-opens', 'java.base/java.lang=ALL-UNNAMED'
	]
}

tasks.withType(JavaCompile) {
	options.compilerArgs += [
		'--add-modules', 'ALL-MODULE-PATH'
	]
}
tasks.named('test') {
	// Use JUnit Platform for unit tests.
	useJUnitPlatform()
}
application {
	// Define the main class for the application.
	mainClass = 'com.commonwealthrobotics.Main'
	applicationDefaultJvmArgs = [
		'--add-exports', 'javafx.controls/com.sun.javafx.scene.control.behavior=ALL-UNNAMED',
		'--add-exports', 'javafx.base/com.sun.javafx.event=ALL-UNNAMED'
	]
}

shadowJar {
	archiveBaseName.set('CaDoodle-Application')
	archiveClassifier.set('')
	archiveVersion.set('')
	zip64 true
	mergeServiceFiles()
}
jar {
	jar.duplicatesStrategy = DuplicatesStrategy.EXCLUDE
	manifest {
		attributes 'Implementation-Title': 'CaDoodle-Application',
		'Implementation-Version': '0.0.1',
		'Main-Class': 'com.commonwealthrobotics.Main'
	}
}
tasks.withType(Copy) {
	duplicatesStrategy = DuplicatesStrategy.EXCLUDE
}
compileJava {
	options.compilerArgs += [
        '--add-exports', 'java.base/java.io=ALL-UNNAMED',
        '--add-exports', 'java.base/java.lang=ALL-UNNAMED',
        '--add-exports', 'java.base/java.util=ALL-UNNAMED',
        '--add-opens', 'java.base/java.lang=ALL-UNNAMED',
        '--add-opens', 'java.base/java.io=ALL-UNNAMED',
        '--add-opens', 'java.base/java.util=ALL-UNNAMED'
		]
}
task printClasspath {
	doLast {
		configurations.compileClasspath.each { println it }
	}
}


eclipse {
	classpath {
		
		downloadSources = true
		downloadJavadoc = true
		file {
			whenMerged {
				entries.forEach { entry ->
					if (entry.kind == 'lib') {
						entry.entryAttributes['module'] = 'true'
					}
				}
			}
		}
	}
	jdt {
		sourceCompatibility = 17
		targetCompatibility = 17
	}
}
task checkForOsgiInJdk {
	doLast {
		def osgiClass = 'org.osgi.framework.Bundle'
		try {
			Class.forName(osgiClass)
			println "OSGi class $osgiClass found in the JDK"
		} catch (ClassNotFoundException e) {
			println "OSGi class $osgiClass not found in the JDK"
		}
	}
}
task printAllDependencies {
	doLast {
		configurations.compileClasspath.resolvedConfiguration.lenientConfiguration.allModuleDependencies.each { dep ->
			println "Dependency: ${dep.module}"
			dep.parents.each { parent ->
				println "   brought in by: ${parent.module}"
			}
		}
	}
}
task printOsgiDependencies {
	println "printOsgiDependencies:"
	doLast {
		configurations.compileClasspath.resolvedConfiguration.lenientConfiguration.allModuleDependencies.each { dep ->
			if (dep.module.toString().contains('osgi')) {
				println "OSGI dependency: ${dep.module}"
				dep.parents.each { parent ->
					println "   brought in by: ${parent.module}"
				}
			}
		}
	}
}

task printJarsContainingFileClass {
	doLast {
		configurations.compileClasspath.each { File file ->
			println "\tChecking "+file
			if (file.name.endsWith(".jar")) {
				ZipFile zipFile = new ZipFile(file)
				zipFile.entries().each { entry ->
					println "\t\t"+entry.name
					if (entry.name == "ai/djl/Device.class") {
						println "Found java/io/File.class in: ${file.path}"
					}
				}
			}
		}
	}
}
